JDBC - Java DB Connectivity(Входит в состав стандартной библиотеки, поставляется вместе с JRE и JDK) собраны все нужные для рабоыт с БД классы и интерфейсы)
JDBC - это прослойка между программистом Java и разрботчиком БД(мы - наш код - JDBC - драйвера БД - БД). ЭТО API для работы с БД.
JAVA APP - JDBC API - JDBC Driver Manager - JDBC Driver - DB(MySql, PostGres ....). JDBC не зависит от типа конкретной базы

Connection-объект отвечает за соединение с БД и режим рабоыт с ней

Statement-объект - выражение обращения к БД

ResultSet-объект результат запроса, который вернула БД  

ORM - Object Relational Mapping - это то, что упаковывет объекты в БД - и наоборот
JPI - Java Persistency API Набор классов и АННОТАЦИЙ, для тех, кто пишет ORM 
Hibernate

DAO - DATA ACCESS OBJECT - объект, позволяющий получить доступ к данным,(некая маленькая ORM)

В Driver Manager регистрируем тот самый драйвер, который нужен для работы с базой конкретного типа(для MySql connector j)
Через DriverManager статическим методом получаем объект типа Connection, в аргументы метода передаются данные о бд, пользователе и тд

JDBC позволяет 	создавать и выполнять запросы к БД
Statement создает объект connection
Uppdate STatements: create, delete, insert(возвращает число измененных строк)
Query Statements: SELECT(возвращает ResultSet)

В ResulSet будет некая таблица(перемещение по строкам: next(), previous(), isLast()) методами getBoolean(Имя поля или индекс) и тд поулчаем данные из ResultSetа

Интерфейсы:
Statement - каждый раз надо создавать новый Statement
PreparedStatement сделать шаблон запроса, в который потом подставлять значения вместе спец символов("?"). Не надо создавать каждый раз новый STatement
CallableStatement

после работы надо:
resultSet.Close()
statement.Close() - закрывает себя и resultSet
connection.Close() - закрывает себя и все, что выше
или использователь AutoCloseable(c 7 java все autoclosable) try with resources

Executor - паттерн для работы с БД, объект, который содержит методы для работы с запросами. 
Из всех действий (вставкой, удалением, изменением данных) вынесесена общася часть, которая занимается непосредственно работой с БД
В каждом нашем действие при работе с базой есть некая неизменяемая часть(создание statementa, стандартная работа со statement, исполнение statementa, закрытие стейтмента) - этим и занимается Executor
execUpdate(connection, строка запроса)вернет integer(количество измененных строк)(stmt.getUpdatedCount())
execQuery(connection, строка запроса, resultHandler) resultHandler - передача функции в аргумент. Это объект класса, который содержит функцию, которая поработает с resultSet
ResultHandler нужен, чтобы Executor сразу мог закрыть connection

Session
Запрос к базе через сессии(аналог statement из JDBC)
на каждый запрос по сессии
время жизни сессии = время жизни транзакции
задача сессии - работа с объектами аннотированными как entity
Ответ от сессии сформирован в виде объекта содержащего entity

Транзакции - это действия, которые могут быть выполнены целиком, либо не выполнены совсем.
Например, при обмене данными между таблицами. БД должна поддерживать тразакции.
AutoCommit - после каждого изменения stetementa база поулчает приказ на сохранения изменения. По умолчанию вкл. После выполнения каждого statementa результат будет сохранен в базу
AutoCommit вызыввается у conncetiona

Аннотации: создаются через @interface ИмяАннотации { }
виды RetentionPolicy:(передаются через аннтоацию @Retention(RetentionPolicy.RUNTIME), указывается перед созданием класса аннотации(перед @interface))
Source - инфо для компилятора, для инструментов IDE. Присутстсвуют только в коде
Class - сохранены в .class, но не доступны в runtime, Доступны при анализе byte-кода, не доступны через рефлексию
Runtime - сохранены в .class, и доступны в runtime. Модно получить из getClass() через рефлексию. 

ORM - это то, что позволяет нам видеть из приложения базу, как-будто там объекты - и наоборот. МОжет собрать объекты на основе записей из таблицы и наоборот.
DAO - центральный элемент ORM, берет объект и превращает его в запрос к базе или предоставляет разработчику функцию, которая из запроса к базе отдает объекты
Если хотим что-то получить от базы, то результат запроса оформляем,как датасет, запрашиваем у ДАО дать данные в виде списка датасетов, и получаем из датасетов объекты.

Java PErsistence API - не работаем с базой запросами, работаем с базой через создание классов со специальной разметкой, сообщаем библиотеке, что у нас есть эти классы
и при запросе "дай мне данные из таблицы" мы на выход получаем объекты этих классов!!! 
Аннотации
@Entity - объект класса можно переложить в таблицу
@Table - связывает класс и конкретную таблицу
@Id - является первичным ключом в таблице
@Column - связывает поле и колонку в таблице

ORM
DataSet - объект содержащий данные одной строки таблицы. В классе которого перечислены поля, эти поля соответствуют данным одной строке таблцы, каждое поле - своей колонке
Создаем датасет, заполняем все поля, которые нужны и сохраняем. При работе с базой приложения вызываем объекты ДАО, либо передаем им датасеты, либо поулчаем от них датасеты.
приходится запрашивать целую строки минимум. 
Датасет - простой класс с полями
DAO - объект для доступа к данным. Один ДАО на одну БД, обычно. ДАО Скрывает реализацию доступа к таблицам
варианты операций над базой:
1) вставка строки - добавление датасета
2) поиска строки по ключу - вовзрат датасета
3) поиск строки по признаку - возврат List<DataSet>
4) удаление строки

Hibernate(скрывает запросы)
поле диалект - подсказка hibernate как именно формировать sql запросы
Hibernate.hbm2ddl.auto автоматически со0здает и проверяет схему базы при создании SessionFactory
validate - проверяет схему, не внося изменений. Проверяет набор классов, которые он получил и разметку имеющейся таблицы
update - Обновляет схему, если есть различия
create - пересоздает схему
create-drop - уничтожает схему при закрытии SessionFactory

SessionFactory
сессия - это юнит, позволяющий делать запросы к базе
Одна фабрика на поток, одна сессия на запрос
У сессия создаем транзацию
Перед созданием фабрики в конфигурацию необходимо передать все классы всех датасетов, которые мои хотим использовать

Запросы к базе через Hibernate
Hibernate Query Language

Интерфейсы помогут реализовать скрытие функций сервисов наружу
Главное, чтобы об имплементации знал только тот, кто создает сервис, все остальные должны знать ою интерфейсе
Дата классы нету смысла делать интерфейсами

Singleton - запрещено создавать более одного объекта класса, экземпляр должен быть доступен с любой точки кода: его не нужно передавать
у синглтона приватный конструктор, чтобы никто не мог снаружи не мог обратиться к нему.
У синглтона есть статическое поле тпиа самого этого класса.
У синглтона должен статический getInstance(), который возвращает ссылку на этот самый класс

Context: содержит Map<Class, объект этого класса>. В контекст закладываются все сервисы, которые необходимы для использования(DbService, AccountService).
В последствии можно передавать в аргументы методам контекст, а не всю грядку сервисов

Исключения - отказ от выполнения задачи
второй способ выхода из функции
возможность вернуть код ошибки
проброс данных через CallStack: дойдет до той функции, у которой есть обработчик, либо выйдет из программы вообще
уведомление вызывающей стороны о некорректных данных
уведомление о состоянии, которое не может код не может исправить
Во время выброски исключения будет собран StackTrace(последовательность вызовов функций, которые привели к исключению)
Error - исключение для JVM(например закончилась память(heap кончился))
RuntIme Exception может выбросить любая функция

CallBack - передача сторонней библиотека совего кода для выполнения в нужный момент

Random class
Берет зерно(лонг число), вырезает середину из числа и опять делает её лонгом

Posix(Unix) время - количество секунд с 1.01.1970

Java.Util.Timer
Java.Util.TimerTask
создаем Timer, создаем класс, унаследованный от TimerTask, в нем в методе run() пишем код, который должен выполниться по таймеру,
передаем в TImer таск и время, через которое надо выполнить таск. Код будет выполняться в другом потоке.
выключаем timer через timer.cancel()

Двустороння связь клиент - сервер
Перезапрос страницы
перезапрос участка страницы
Long Polling - клиент сразу же отправляет запрос на сервер и ждёт, пока ответ не придет(ответ может не приходить долго)
Socket - интерфейс взаимодействия приложений друг с другом
WebSocket - канал связи между клиентом и сервером(клиент может написать и это уйдет на сервер, и сервер может написать в этот канал и это уйдет клиенту)



