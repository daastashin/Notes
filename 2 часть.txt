Критерии качества: набор условий, которым должен соответствовать приложение

Автоматизация обеспечения качества:
статический анализ кода(среда проверяет)
тесты - после прохождения тестов всё отправляем в систему контроля версий
коммит-хуки - запускаются на стадии передачи в систему контроля версий, это доп плагины к системе контроля версий, которые перехватывают, 
	что им посылают и анализируют это перед тем, как вставить в репозиторий	 
непрерывная интеграция - дполнительный более сложный анализ

Методы тестирования: белый ящик(знаем код) и черный ящик(не знаем код)

Юнит-тесты - для метода белого ящика, позволяет протестировать некий небольшой кусок функционала
- 100% контроль окружений какой-то функции
- пишут все программисты
- перед отправкой изменений проверяются самим программистом
- после коммита изменений првоеряются системой Continuous Integration
- Метрика - покрытие кода тестами

функциональное тестирование - првоерка взаимодействия модуля друг с другом( все по-настоящему)

нагрузочное тестирование - проверка сервера нагрузкой
Метрика - макс число пользователей, чтобы система еще номр работала

Безопасный рефакторинг - сначала описываем тестами код, который хотим заменить, заменяем код, запускамем тесты, фиксим отличия

Необходимы тесты на проверку совместимости

Test Driving Development - создание тестов до функционала

Требования к юнит тестам:
- независимость о твнешних факторов(версия jdk, среда разработки ..)
- независимость от порядка выполнения
- зависимость от боевого кода(тест должен тестировать что-то реальное, а не просто заглушки)
- минимум перекрытий(пересечения с другими тестами или с общими частями кода)
- один тест - одна проверка
- повторяемость результатов

TestDoubles - дублеры
- повышение скорости тестов
- независимость от окружения
- полное покрытие
- свой человек
виды дублеров:
Dummy - просто заоплнить параметр
Fake - упрощенная и/или неподходящая для боевого серверас работающей реализацией
Stubs - заглушка для вызовов в тесте, првоеряет состояние(более ограниченный функционал, чем Fake)(Делаем тестовый класс, который наследуется от требуемого класса/интерфейса, 
реализуем у него требуемый для првоерки метод, заводим переменную, которую выставляем в тру, если этот метод был вызыван. Создаем объект этого класса, отдаем этот объект тестируемуму объекту/методу
Spies - это stub, следящий за информацией о вызовах, контролирует происходящее
Mocks - объект, заменяющий настоящие с заранее заланными условиями

Абстракция

Функциональное тестирование - это необходимое, но недостаточное условие работоспособности
Функциональные тесты(позволяют связать вместе разные части системы):
Реализуется-ли требуемый функционал
поднятие сервера
взаимодействие нескольких модулей
вход в игру

Нагрузочное тестирование: создание некой модели пользователя
Анализируем поведение настоящих пользователей, записываем их дейсвтия, что и когда они сделали, и пытаемся воспроизвести тоже самое, только ассинхронно с разных направлений
на сервер, пятаясь сымитировать тот же нагрузочный прфоиль

Организация нагрузочного тестирования:
Список активностей пользователей(что вообще можно делать с системой)
параметры активностей(активности по частотам?)
Реализация бота
проведение испытаний
анализ испытаний(на сколько хорошо живет сервис при нагрузке, какой профиль получился после нагрузки)

Инструменты:
jMeter, Yandex-tanki, Gatling, свой личный

Результаты нагрузочного тестирования:
ПОтребление процессора ССU %
обращение к диску (iowait) 
сеть Гб/с
время отклика(Восприятие пользователем отклика от системы)
Response time(время, которое сервер тратит на 1 тик работы)
CCU, users
Использование памяти, Гб

Тик сервера - это запланированное время непрерывной работы сервера (в наносекундах)

Не спать вредно - CPU Starvation
МНого спать тоже вредно
Чем больше нагрузка на CPU, тем лучше

Сборщик мусора(может двигать объекты по памяти в процессе жизни объектов):
Ищет недостижимые из стека объекты
у удаляемого объекта вызывается finalize()
Типы ссылок:
Strong ref - сиьно достижимый объект, тот к которому можно дойти по ссылкам
Weak ref - возможность запомнить ссылку на объект (не дают гарантию, что объект существует)
Soft ref - держит ссылку на объект, пока достаочно памяти
Phantom ref - уведомление, о том, чт опроизошло удаление обхекта

GARBAGE COLLECTOR(может двигать объекты по участкам памяти) {
HotSpoyt JVM память можно было разбить на 3 части:
Память под стеки(на каждый поток по стеку)
память под heap
Permanent Generation - место, где лежит инфа о классах(Java 7), начиная с Java8 - MaxMetaSpaceSize - область в heap(туда складывается все то, что раньше складывалось в PermGen)

ClassLoader загружал информацию о классах в Permanent Generation.
Еще в perm Gen лежала инфа о JVM

Heap делится на 2 физически разных участка памяти:
New Gen
Old Gen (лежат объекты, которые пережили множественное количество сборок мусора)

New gen содержит в себе следующие области памяти: Eden, Survivor1, Survivor2
В Eden, создается объект. Если в время сборки мусора объект имеет живую ссылку до стэка, то объект перемещается в Survivor1.
Если еще раз пережил сборку мусора, то его перемещают в Survivor2. если еще раз пережил сборку, то он перемещается в Old Gen.
Чем дальше объект от Edenа, тем реже сборщик будет проверять его на предмет живой связи до стэка. Сложнее всего чистить old gen.
old Gen чистится во время fullGC()
}
параметры JVM7(выставляются заранее):
XXPermSize, XXMaxPermSize - количество памяти под PermGen до Java8, начиная с Java8 только - XXMaxMetaSpaceSize
Xms, Xmx - размер heap(обычно равны друг другу, чтобы под хип выелялась сразу максимум памяти(не надо в последствии проводить повторный allocation)
XXNewSize, XXMaxNewSize - размер под NewGen(тоже обычно равны друг другу)

IO Stream
2 абстрактных класса: InputStream и OutputStream
у InputStream:
abstract int read() - возвращается байт за байтом из входного потока или -1, если конец потока
int read(byte[] d) - возвращает число прочитанных байт
mark(int readLimit) - отметить место, к которому потом вернуться
reset()
close()
		|FileOutputStream(работают с устройсвами: принтер и тд)
OutputStream ->		               |printSTream
            	|FilterOutputStream -> |BufferedOutputStream
		                       |DataOutputStream

		|FileInputStream(работают с устройсвами: термометр и тд)
InputStream ->		              |BufferedInputStream
            	|FilterInputStream -> 
		                      |DataInputStream

Паттерн Декоратор
ребенок FilterInputStream содержит ссылку на объект родителя(InputStream), переопределяя все методы InputStream вызывая методы InputStream
Наследник этого класса могут менять работу потока в поле in, через изменение методов родителя.
//для начала откроем outputStream для файла
FileOutputStream out = New FileOutputStream(fileName) //здесь можно начать по-байтово писать данные, но это очень долго для этого:
BufferedOutputStream bout = New BufferedOutputStream(out) //модифицируем данные так, чтобы запись шла не по-байтно, а сразу неким куском. Далле передаем в ObjectOutputStream
ObjectOutputStream dout = New ObjectOutputStream(bout) // Нужно записать объект - используем ObjectOutputStream
//пишем
dout.writeObject(object)
dout.flush()

Потоки надо закрывать!. поэтому все потоки AutoCloseble(содержит close()). Потоки используем в try catch, система сама закрывает поток

Interface VFS(Virtual File System) - модуль для работы с файлами
ЕСТЬ метод Iterator<String> getIterator(String startDir) - пробежаться по всей файловой системе, с учетом того, что там могут быть подкаталоги
Должна содержать корневую директорию - ту директорию, которую VFS будет считать корнем(передаем путь к этой директории в конструктор)

File - представление пути к файлу или директории
Скрывает от приложения детали пути к файлу конвретной ОС
по умолчанию ищет файл в директории src
основные методы: boolean exists(), String getAbsolutePath(), boolean isDerictory(), booleanCreateNewFile(), boolean mkdir(), boolean delete(), boolean deletOnExit()(удалить при выходе из приложения

Серилизация - перевод данных одного формата в другой(например, в котором их удобно хранить) и назад
например, blob - сырых данных
Interface Serializable - реадизует методы, которые позволяют превратить объект в массив байт(бинарная сериализация) и назад. ЭТО ПУСТОЙ!!! ИНТЕРФЕЙС
Сериализацией занимается ObjectOutputStream
Все поля сериализуемого объекта должны быть 
все поля будут сериализованы. Помеченные transient - не будут, статические поля тоже не будут, при десериализации эти поля будут заполнены значениями по-умолчанию(например нулл)
Поля родительских классов, реализующих Serializable будут сериализованы
Если родительский класс не реализует Serializable, то при десериализации для него будет вызван конструторк по-усолчанию
Если хотя бы один родитель в цепочке наследований оказался не Serializable, то сериализация остановится на этом классе, даже если его родители - Serializable

Десериализация:
1) род классы
2) классы переменных род классов
3) объекты род классов
4) значения переменных род классов
5) классы переменных
6) значения переменных

Reflection
Возможность проверить структуру и изменить поведение объекта в runtime
Сериализация работает через рефлексию, рефлексия проходит по полям объекта, накидывает разные метаданные и складывает в массив байт.
Через рефлексию массив байт делается объектами
минусы рефлексии: разрушении объектно-ориентированной архитектуры, потеря производительности, не работает в окружении с повышенной безопаностью
Class - объект, который представляет в runtime данные о классе объекта:
static Class<T> forName(string className), String getCanoncialName(), Fields[] getFielad(String name), Class[] getInterfaces(), Method[] getMethods(), Constructor[] getContructors()

ReflectionHelper: свой класс со статическим методами для работы через рефлексию
public static createInstance(String className) {
try {
return Class.forName(className).newInstance() }
catch {
}}

public static void setFieldValue(Object object, String fieldName, String value) {
try {
Field field = object.getClass().getDeclaredField(fieldName) (getDeclaredField ищет по все полям, getField - только public поля)
field.setAccessable(true) 

if(field.getType().equals(String.class)) {
	field.set(object,value)
else if (field.getType().equals(int.class)) {
	field.set(object,Integer.decode(value))
}

field.setAccessable(false)
} catch(...) {...}
}

Класс Propeties - класс для организзации данных типа ключ-значение, лажащих в отдельном файле(анпример, config.properties)
try (InputStream input = New FileInputStrream(config.properties()) // иными словами try with resources, после выполнения кода input будет автоматически закрыт(AutoCloseable)
properties.load(input)
properties.getProperty("propety name")

XML Serialization
XML - иерархическая структура
в bin файле невозможно просто поменять какую-то часть, файл просто не прочитается джавой
в XML можно просто блокнотом отредактировать
в XML нет привязок к типу
нет привязки к особоенностям языка
Избыточная структура файла
Медленные чтение и запись

SAX Parser - API for XML
обходит XML дерево
Посещает каждую ноду дерева
для каждой ноды вызывает 3 callbacka(Начали работу, передача содержимого, закончили работу)
Порядок работы:
читаем формат документа
читаем первый тег - сообщает приложению, что обработка началась
читаем содержимое тега
Сообщаем приложению содержимое тега
Рекурсивно обращаемсч ко всем вложенным тегам
Сообщаем приложению, что обработка завершена
3 Callbacka:
startElement() - создаем объекта класса или запоминаем имя тега
characters() - задаем значение поля тега
endElement() - зануляем временную переменную

DOM parser - Document Object Model
Сначала читаем весь XML, потом обойдем все ноды, в отличии от SAX parsera, который читает по одной ноде.
DOM parser может читать файл с конце, с сереины

Resource - интерфейс для всех объектов со статич данными
Конкретный ресурс можно собрать но основе XML документов
Ресурс одного типа может быть описан несколькими XML документами(для разных ситуаций)
Уникальность ресурса - уникальный путь к этому XML файлу

REsource system - набор файлов с конфигурациями для приложений

ResourceFactory фабрика ресурсов, возвращает объект ресурса по пути к XML файлу

NIO (non-blocking IO)
Возможность читать/писать и делать что-то еще
Лучше использует возможности железа, но при этом платформозависима
Base of async network(many weakly loaded connections)
    IO           VS       NIO
блокировка thread |  Без блокировки threada(можно выбрать с блокировкой)
streams           |  Буферы (сущность, через которую идет обмен данными. Позволяет работать с источником данных в обе стороны)
                  |  Селекторы (Позволяет получать уведомления, позволяет следить за несколькими задачами одновременно)

Основные элементы NIO
Channels, Buffers, Selectors, Path

Chanel - аналога стрима в IO, канал можно использовать для чтения и записи. Могут читать в буфер и писать в буфер асинхронно

Buffer - промежуточный контейнер
Capacity - размер буфера
limit - cовпадает с capacity, если буфер находится в режиме записи. В режиме чтения в конце записи limit устанавливается на позицию, до которой была последний запись 
position - место, где в данный момент находимся
Selecotr - позволяет следить за несколькими кналами одновременно по событиям(Connect, Accept, Read, Write), при наступлении события, вызывается callback(наш код для события)
и что-то там происходит









