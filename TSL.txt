3 главные цели TSL:
	Confidentiality - никто третий не может прочитать сообщение. Обсепечивается шифрованием
	Integrity - никто третий не может изменить сообщение. Обеспечивается хэшированием
	Authentication - клиент или сервер действительно являются клиентом или сервером, а не кем-то другим. Обеспечивается PKI(Public key Infrastructure)

PKI(Public key Infrastructure) - треугольник, по углам которого клиент, сервер и CA

MAC - message auth code - сообщения и секретного кода через хэш код
	Важен порядок расположения сообщения и секретного кода.

Алгоритм хэширования:
	на входе сообщение, на выходе хэш-сумма. Например MD5, SHA256 и ...
МАС:
	на входе сообщение + секретный код, на выходе хэш-сумма. Например HMAC (Hash Based Message Auth code)
	
Шифрование для обеспечения Confidentiality. Шифрование преобразует данные: hello - ellho
	Симметричное шифрование - подходит для больших данных
		шифрует и дешифрует данные одними и теми же ключами
		оно быстрее. Зашифрованный текст того же размера
		публичный ключ должен быть передан явно
		менее безопасно
		Алгоритмы: AES, ChaCha20. Примерный размер ключа ~200 бит
		
	Асимметричное шифрование - Не предназначено для больших объёмов данных
		шифрует и дешифрует данные разными ключами(encyption key и decryption key). encyption key и decryption key могут быть взаимозаменяемые, напр: шифровать ключом дешифрования и наоборот
		Оно медленне
		Зашифрованный текст увеличивается в размере
		Более безопасно
		Алгоритмы: DSA, RSA, Diffie-Hoffman, ECDSA, ECDH. Примерный размер ключа ~2048 бит

	Можно использовать ассиметричное шифрование для обмена ключами и симметричное шифрование для передачи больших объемов данных - это и есть TLS

Public and Private Keys

Signature:
Integrity отправляем хэш сообщения и само сообщение. На другой стороне опять вычисляется хэш сообщения и если хэш сообщения и соответсвует переданному хэшу сообщения, значит сообщение - полное
Используется приватный ключ отправителя для того, чтобьы зашифровать хэш сумму сообщения - это и есть signature		

CA Certificate Authority:
	клиент доверяет CA
	CA генерит сертификат, который связывает пару асимметричных ключей с определенной личностью
	Сертификат подписан CA
	Имеет свою пару ключей 
	Имеет self-signed сертификат с публичным ключом

RSA: Сервер генерит 2 произвольных простых числа (P,Q), получаем их произведение N = P*Q, вычисляем тотиент T = (P-1)*(Q-1). 
	Затем выбираем публичный ключ(E), он должен быть: простым числом, должен быть меньше тотиента и НЕ ДОЛЖЕН быть одним из множителей тотиента
	Затем выбираем приватный ключ(D): должно выполняться условие: (D*E) MOD T = 1: остаток от деления произведение публичного ключа и првиатного на тотиент должекн быть равен 1
	Например: P=7, Q=19, тогда N=133, T=108, E=29, D=41.
	Сервер открыто отправляет клиенту N(произведение заданных простых чисел) и E(публичный ключ)
	
	Шифрование: message^E MOD N = cipher text
	Дешифрование: cipher^D MOD N = message
	
	Безопасность RSA определяется количеством бит на число N, если число N будет длиной 1024 бит - это будет десятичное число длиной примерно в 300 символов
	
Если взять простое число p и число g, то: Возводя g в степень 1 , 2 , 3 , … , p − 1, и вычисляя остаток от деления на p, Мы должны получить все числа от 1 до p − 1 без повторений. Тогда g - первообразный корень.
Diffie-Hellman: 
	сервер и клиент определяют простое число G и первообразный корень простого числа P. Затем обе стороны генерируют секретные ключи Private в виде рандомных чисел.
	Затем для каждого вычисляется публичный ключ по формуле public = (G^Private) MOD P. Затем обмениваются публичными ключами. 
	Затем каждая из сторон вычисляет shared secret на основании публичных ключей друг друга: shared secret = (public другого^private) MOD P. У обеих сторон должен поулчиться один и тот же shared secret
	С помощью shared secret генерятся ключи для симметричного шифрования

Последовательность TLS:
	1) CA Имеет свою пару ключей. Имеет self-signed сертификат с публичным ключом
	2) Сервер хочет получить сертификат
	3) Сервер генерит свою пару ключей
	4) Сервер генерит Certificate Signing Request(В нём публичный ключ). Этот запрос подписан приватным ключом
	5) Сервер отправляет CSR to CA 
	6) CA проверяет и валидирует информацию в CSR, чтобы убедиться, что сервер - это сервер
	7) CA создает сертификат, используя информацию из CSR. Этот серт содержит публичный ключ сервера и подписан приватный ключом CA
	8) Этот серт связывает определенный набор асимметричных ключей сервера с сертификатом, который создан в п.7. Это гарантируется СА
	9) СА отправляет этот сертификат серверу
	10) Сервер теперь может подтверждать себя жтим сертификатом
	11) Клиент уже имеет предустановленный сертификат СА
	12) Клиент запрашивает серт сервера и проверяет его signature, используя публичный ключ СА. Клиент проверяет: действительно-ли публичный в полученном сертификате соответствует приватному ключу сервера?
	13) Это все называется handshake, во время handshake клиент и сервер обмениваются кусчками информации, чтобы обеспечить 2 условия: валидация сертификата сервера и то, что сервер - это действительно сервер
		handshake так же позволяет определить симметричные ключи для сервера и клиента
	14) handshake создает session keys для защиты больших объёмов данных: симметричные ключи для confidentiality и симметричные ключи для Message Auth Code(MAC) для intehrity И authentication
	15) Session keys создают безопасный туннел для обмена данными между клиент и сервером

Cipher suite определяет: key exchange protocol, authentication protocol, asymmetric encryption protocol, hashing algorithm
например: TLS_DHE_RSA_WITH_AES_256_CBC_SHA. Здесь DHE - key exchange protocol, RSA - authentication protocol, AES_256_CBC - asymmetric encryption protocol, SHA - hashing algorithm

HSTS - Http Strict Transport Security 