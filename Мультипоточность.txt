Процессы - приложение со своим набором run-time ресурсов и собственной памятью. Взаимодействие через Inter Proceess Communication ресурсы. МОжно запускать на нескольких компах
Потоки не являются отдельным приложением, живут в одном процессе. Используют общую память(heap) и другие ресурсы приложения. Старт приложения - создание main потока. 
Потоки могут пораждать другие потоки и взаимодействовать с ними
На фабрике потоки - линии конвейером, а процесс - это сама фабрика

Операционная система создает потоки, переключает потоки(context и Switch, API Для уведомления потока(например пробуждение потока)
Для создания потоков: класс: Runnable или класс extends Thread

Thread.currentTHread() - получить ссылку на объект текущего потока
методы потока: 
getID(), 
getName(), 
getPriority()(задать приоритет, ОС сама решает кому сколько выделить памяти в зависимости от приоритета),
setPriority(),
sleep()(поток на паузу на какое-то время, при этом он не проснется раньше, но может прсонуться позже(зависит от ОС)),
interrupt() если поток спит, то это разбудит поток и приведет к Interrupted exception, если не спит, то в свойстве interrupted у потока будет true. При этом ПОТОК НЕ ОСТАНОВИТСЯ!!
isInterrupted() - поток мягко попросили остановиться
join()

Mutex - двоичный семафор. МОжет находится только в 2 состояниях - отмеченном и неотмеченном
Critical Section - участок кода, к которому доступ на исполнение должен быть только у одного потока(например запись в файл)
Monitor - объект, который следит за тем, чтобы кто-то мог зайти в критическую секцию, а все остальные ждали, пока 1-ый выйдет, после выхода первого - уведомит следующего
Semaphore - объект, ограничивающий количество потоков, которые могут иметь доступ к ресурсу
Lock мягкая блокировка и обязательная блокировка(выброс исключения при попытке доступа к заблокированному ресурсу

Volatile - загрузка переменной в общую память, НЕ В КЭШ

Synchronized { coode } - синхронизируемся на объект(занимаем у него монитор), по умолчанию синхронизация идёт на this. У каждого объекта в java есть header, в  хэдере есть Mark Word,
В заголовке объекта в Mark Word выставится соответствующий тэг и запись о том, к какому потоку привязан монитор.


ExecutorService es = Executors.newFixedThreadPool(N) - выделяем количество потоков на задачу через  es.submit(new Work(i)); es.shutdown();. Каждая новая задача запускается в новом потоке.
Work - класс, в котором переопределен Run, имплементит Runnable.
объект Executor service создан с помощью фабрики, там еще есть newSingleThreadExecutor() и newScheduledThreadPool(3)
awaitTermination() - ждем пока все потоки из ExecutorService выполнят свои дела
es.execute() - просто запускает поток(выстрелил и забыл)
es.submit(Runnable) - запускает поток, возращает объект Future(там инфа о состояние потока). future.get() - Блокирует поток до получения результата.
Runnable - ничего не возвращает, а Callable - может вернуть какой-то результат(нужно для обмена данными между потоками)
shutdown() - все задачи будут завершены, новые задачи не будут приниматься

ArrayBlockingQueue(N) - потокобезопасная коллекция из N элементов

Паттерн Producer - Consumer - один что-то делает, другой - запрашивает результат. Например: Producer кладет элемент в ArrayBlockingQueue, Consumer - забирает элемнт оттуда

wait() - останавливаем поток, отдаем intrisinic lock, начинает выполнятся другой метод, который также синхронизирован на этом же объекте.
Ждём, когда будет вызван notify() в другом методе и код в этотм методе дойдет до конца блока synchronized {}
Выполняется при синхронизации на одном объекте с методом, в котором есть notify()

CountDownLatch - класс защелка. Передаем туда число-счетчик. В потоках декрементируем счетчик с помощью coundDownLatch.countDown(). В главном потоке вызываем метод coundDownLatch.await(), 
который блокирует выполнение главного потока, пока счетчик не станет равен нулю, далее выполнение главного потока продолжится

ReentrantLock() - можно делать lock.lock() - забираем монитор объекта, lock.unlock() - освобождаем монитор объекта

Semaphore - для регулирования количества потоков на задачу. acquire() - забирает поток, release() - освобождает. Если свободных ресурсов нету, то выполнение остановится на acquire(), 
и программа будет ждать, пока где-то не будет вызван release() 

DeadLock - создаем 2 ReentrantLocka. В одном метода вызываем lock1.lock(); lock2.lock();, в другом месте уже начинает выполняться lock2.lock(); и lock1.lock();,
Получается, что мы забрали lock1 у первого метода, и lock2 - у второго, и никто из них не может пройти дальше. Для исключения подобной ситуации используется:
бесконечный while, в котором  lock1Taken = lock1.tryLock();, lock2Taken = lock2.tryLock(); повторяется через какое-то время, и в итоге разлочиваем оба лока, если они оба заняты
Также дедлок можно сделать на вложенный блоках synchronized, если синхрониться в неправильном порядке

Thread.currentThread().isInterrupted() - прерывание потока(у потока был вызван interrupt())
Thread.sleep() - усыпить текущий поток(статический метод)
myThread.interrupt() - остановка потока(если у потока был вызван join или sleep, ожидание будет прервано, и программа выбросит InterruptedException)



