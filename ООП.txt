Принципы ООП:
	Абстракция - Выделение ключевых характеристик объекта и игнорирование несущественных деталей.
	Инкапсуляция - Сокрытие внутренней реализации и предоставление методов для работы с объектом
	Наследование - Возможность создания новых классов на основе существующих с переиспользованием их функциональности.
	Полиморфизм - Возможность объектов с одинаковым интерфейсом иметь разную реализацию. 
                      Перегрузка методов (один метод, разные параметры).
		      Переопределение методов (наследник изменяет поведение родителя).
		      Пример: интерфейс Shape с методами draw(), который по-разному реализован в Circle и Square.
Принципы SOLID:
1. S: Принцип единственной ответственности (Single Responsibility Principle, SRP)
	Каждый класс должен иметь только одну ответственность или задачу, 
	и эта задача должна быть полностью инкапсулирована в пределах класса. 
	Это означает, что у класса должна быть только одна причина для изменения. 
	Например, если класс отвечает за взаимодействие с базой данных и 
	одновременно за представление данных пользователю, он нарушает SRP.
2. O: Принцип открытости/закрытости (Open/Closed Principle, OCP)
	Классы должны быть открыты для расширения, но закрыты для изменения. 
	Это означает, что при добавлении новой функциональности не следует изменять существующий код, 
	а лучше расширять его через наследование или другие механизмы.
3. L: Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)
	Объекты должны быть заменяемы экземплярами их подклассов без нарушения корректности программы. 
	Наследник должен сохранять поведение родителя, чтобы его можно было использовать вместо родительского класса 
	без неожиданного поведения. 
	Например: Создать класс "птица", унаследовать класс "Пингвин" от "Птица", 
	у которого метод fly переопределен и выбрасывает исключение т.к. пингвины не летают
4. I: Принцип разделения интерфейса (Interface Segregation Principle, ISP)
	Клиенты не должны зависеть от интерфейсов, которые они не используют. 
	Другими словами, лучше иметь несколько специфичных интерфейсов, чем один универсальный, 
	который заставляет реализовать ненужные методы.
5. D: Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)
	Высокоуровневые модули не должны зависеть от низкоуровневых; оба должны зависеть от абстракций. 
	Это означает, что детали реализации должны быть отделены от логики. 
	Важная часть этого принципа — внедрение зависимостей (dependency injection), 
	которое помогает избежать жесткой зависимости от конкретных реализаций.
	Например: реализация интферфейса для взаимодействия с БД, 
	чтобы можно было легко менять базы данных на ходу, а не менять целый сервис

Паттерны: 
	Пораждающие(создание объектов):
		Билдер - создание сложных объектов через какой-нить append
		Фабрика - создаёт объекты суперкласса без указания их конкретного типа. Создание пиццы через фабрику пицц
		Абстрактная фабрика - управляем “выпуском” различных семейств взаимосвязанных объектов. 
			Абстрактная фабрика предоставляет интерфейс создания всех имеющихся продуктов (объектов семейства). 
			У абстрактной фабрики, как правило, есть несколько реализаций. 
			Каждая из них отвечает за создание продуктов одной из вариаций.
		Прототип - создание нового объекта, путем копирования существующего, через его внутренний метод clone().
			Затем можно изменить, нампример, "имя склонированной овцы".
		Синглтон - ограничение на создание объекта. Может быть только один, и доступ через статич поле.

	Структурные(построение связей между объектами): 
		Адаптер - преобразовать интерфейс одного класса в другой интерфейс, ожидаемый клиентом. 
			Благодаря этому классы с несовместимыми интерфейсами могут работать вместе без изменения их исходного кода.
		Декоратор - позволяет расширять функциональность объекта без изменения его исходного кода. 
			Оборачивается в новый класс с расширением функциональности
		Фасад -  предоставляет единую точку входа для управления сложной системой и позволяет не вникать в её внутреннюю структуру.
			Типа домашнего кинотеатра. "Кинотеатр - включись" и включается объект музыка, включается объект проектор и пр.  
	
	Поведенческие(взаимодействия между объектами):
		Стратегия - Выбор алгоритомв. При оплате продукта можем выбрать тип оплаты: картой ил qr-кодом. И затем у выбранного типа оплаты вызвать метод оплатить()
		Наблюдатель - Организация связи между объектами по принципу «один ко многим». Когда основной объект (субъект) меняет своё состояние, 
			все зависимые объекты (наблюдатели) автоматически получают уведомление и обновляются. Соц сеть: подписчики получают уведомление о новом посте и что-то там у себя делают.
		Посетитель - Позволяет добавлять новую функциональность к классам без изменения их исходного кода. Добавляем визитером в зоопарке с конкретной задачей в общем интерфейсе 
		